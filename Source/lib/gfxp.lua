 -- GFXP for Playdate (https://github.com/ivansergeev/gfxp)
 -- 2020 Â© GFXP is brought to you by Ivan Sergeev

--[[ 
	Example of use GFXP lib

	Option 1:
		local gfxp = GFXP
		
		-- in the code, specified pattern name
		gfxp.set('gray')
		
		-- or the specified pattern table
		gfxp.set({0xE7, 0xDB, 0xBD, 0x7E, 0x7E, 0xBD, 0xDB, 0xE7})
		
		-- or the specified pattern name
		playdate.graphics.setPattern(gfxp.gray)
		
	Option 2:
		
		-- in the code, specified pattern name
		GFXP.set('gray')
		
		-- or the specified pattern table
		GFXP.set({0xE7, 0xDB, 0xBD, 0x7E, 0x7E, 0xBD, 0xDB, 0xE7})
	
	Option 3:
	
		-- the specified pattern name
		playdate.graphics.setPattern(GFXP.gray)	
	
]]--

GFXP = {
	
	-- Grayscale
	white = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
	black = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
	
	lightgray = {0xFF, 0xDD, 0xFF, 0x77, 0xFF, 0xDD, 0xFF, 0x77},
	
	gray = {0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA},
	gray2 = {0x33, 0x33, 0xCC, 0xCC, 0x33, 0x33, 0xCC, 0xCC},
	gray3 = {0x33, 0x33, 0x33, 0x33, 0xCC, 0xCC, 0xCC, 0xCC},
	gray4 = {0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA},
	gray5 = {0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55},
	gray6 = {0xD2, 0x5A, 0x4B, 0x69, 0x2D, 0xA5, 0xB4, 0x96},

	darkgray = {0x0, 0x22, 0x0, 0x88, 0x0, 0x22, 0x0, 0x88},
	darkgray2 = {0x88, 0x88, 0x22, 0x22, 0x88, 0x88, 0x22, 0x22},
	darkgray3 = {0x88, 0x88, 0x88, 0x88, 0x22, 0x22, 0x22, 0x22},
	
	-- Dots
	dots1 = {0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
	dots2 = {0x80, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0},
	dots3 = {0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
	dots4 = {0x7F, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF},
	dots5 = {0x3F, 0x3F, 0xFF, 0xFF, 0xF3, 0xF3, 0xFF, 0xFF},
	dots6 = {0xC0, 0xC0, 0x0, 0x0, 0xC, 0xC, 0x0, 0x0},
	dots7 = {0x1F, 0x5F, 0x1F, 0xFF, 0xF1, 0xF5, 0xF1, 0xFF},
	dots8 = {0xE0, 0xA0, 0xE0, 0x0, 0xE, 0xA, 0xE, 0x0},
	dots9 = {0xF, 0x6F, 0x6F, 0xF, 0xF0, 0xF6, 0xF6, 0xF0},
	dots10 = {0xF0, 0x90, 0x90, 0xF0, 0xF, 0x9, 0x9, 0xF},
	dots11 = {0xFF, 0xFF, 0xE7, 0xDB, 0xDB, 0xE7, 0xFF, 0xFF},
	dots12 = {0x0, 0x0, 0x18, 0x24, 0x24, 0x18, 0x0, 0x0},
	dots14 = {0xAA, 0xAA, 0x55, 0x55, 0xBA, 0xBA, 0x55, 0x55},
	dots15 = {0xAB, 0xAB, 0x55, 0x55, 0xBA, 0xBA, 0x55, 0x55},
	dots16 = {0x55, 0xAA, 0x41, 0x9C, 0x5D, 0x9C, 0x41, 0xAA},
	dots17 = {0x9F, 0x6F, 0x6F, 0x9F, 0xF9, 0xF6, 0xF6, 0xF9},
	dots18 = {0xFF, 0xE3, 0xDD, 0xBE, 0xBE, 0xBE, 0xDD, 0xE3},
	dots19 = {0xFF, 0xE3, 0xC1, 0x80, 0x80, 0x80, 0xC1, 0xE3},
	dots20 = {0x0, 0x1C, 0x3E, 0x7F, 0x7F, 0x7F, 0x3E, 0x1C},
	dots21 = {0x0, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x0},
	dots22 = {0xBB, 0xF5, 0xF5, 0xF5, 0xB5, 0x5B, 0x5F, 0x5F},
	dots23 = {0xBD, 0x5A, 0xA5, 0xDB, 0xDB, 0xA5, 0x5A, 0xBD},
	
	-- Flakes
	flakes1 = {0x7E, 0xBD, 0xC3, 0xFB, 0xFB, 0xFB, 0xFD, 0xFE},
	flakes2 = {0x7E, 0xBD, 0xC3, 0xFB, 0xEB, 0xDB, 0xBD, 0x7E},
	flakes3 = {0xE3, 0xDD, 0xBD, 0x7E, 0x7E, 0x7E, 0x9F, 0xE3},
	flakes4 = {0x7E, 0xBD, 0xBB, 0xB7, 0x8F, 0xEF, 0xE1, 0xFE},
	flakes5 = {0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xC3, 0xA5, 0x66,},
	flakes6 = {0x7E, 0xBD, 0xC3, 0xDF, 0xDF, 0xDF, 0xBF, 0x7F},
	flakes7 = {0xF7, 0xF7, 0xEB, 0x1C, 0x7F, 0x7F, 0xBE, 0xC1},
	
	-- Crosses
	cross1 = {0xFF, 0xFF, 0xFF, 0x77, 0xAF, 0xDF, 0xAF, 0x77},
	cross2 = {0xFF, 0xBE, 0xDD, 0xEB, 0xF7, 0xEB, 0xDD, 0xBE},
	cross3 = {0x55, 0xAA, 0x55, 0xBE, 0x5D, 0xBE, 0x55, 0xAA},
	cross4 = {0xFF, 0xDD, 0xAA, 0xD5, 0xEB, 0xD5, 0xAA, 0xDD},
	cross5 = {0xFF, 0xE7, 0xE7, 0x99, 0x99, 0xE7, 0xE7, 0xFF},
	cross6 = {0xFE, 0x38, 0xFE, 0xEE, 0xEF, 0x83, 0xEF, 0xEE},
	
	-- Vertical Lines
	vlines1 = {0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F},
	vlines2 = {0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77},
	vlines3 = {0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D},
	vlines4 = {0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55},
	vlines5 = {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
	vlines6 = {0xF7, 0xF7, 0xF7, 0xF7, 0x7F, 0x7F, 0x7F, 0x7F},
	vlines7 = {0x80, 0x80, 0x80, 0x80, 0x8, 0x8, 0x8, 0x8},
	
	-- Horizontal Lines
	hlines1 = {0x0, 0xFF, 0xFF, 0xFF, 0x0, 0xFF, 0xFF, 0xFF},
	hlines2 = {0x0, 0xFF, 0xFF, 0x0, 0xFF, 0xFF, 0x0, 0xFF},
	hlines3 = {0x0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
	hlines4 = {0x0, 0xFF, 0x0, 0xFF, 0x0, 0xFF, 0x0, 0xFF},
	hlines5 = {0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
	hlines6 = {0xFF, 0x14, 0xFF, 0xA2, 0xFF, 0x14, 0xFF, 0xA2},
	hlines7 = {0xF, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF},
	hlines8 = {0xF0, 0x0, 0x0, 0x0, 0xF, 0x0, 0x0, 0x0},
	
	-- Diagonal Lines
	dlines1 = {0xFE, 0xFD, 0xFB, 0xF7, 0xEF, 0xDF, 0xBF, 0x7F},
	dlines2 = {0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80},
	dlines3 = {0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1},
	dlines4 = {0x77, 0xBB, 0xDD, 0xEE, 0x77, 0xBB, 0xDD, 0xFE},
	dlines5 = {0xFF, 0xFF, 0xF7, 0xEF, 0xDF, 0xBF, 0x7F, 0xFF},
	dlines6 = {0xFC, 0x7E, 0x3F, 0x9F, 0xCF, 0xE7, 0xF3, 0xF9},
	dlines7 = {0xF8, 0x7C, 0x3E, 0x1F, 0x8F, 0xC7, 0xE3, 0xF1},
	
	-- Net
	net1 = {0x0, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F},
	net2 = {0x0, 0x77, 0x77, 0x77, 0x0, 0x77, 0x77, 0x77},
	net3 = {0x0, 0x6D, 0x6D, 0x0, 0x6D, 0x6D, 0x0, 0x6D},
	net4 = {0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
	net5 = {0xFF, 0x88, 0x88, 0x88, 0xFF, 0x88, 0x88, 0x88},
	net6 = {0xE7, 0xDB, 0xBD, 0x7E, 0x7E, 0xBD, 0xDB, 0xE7},
	net7 = {0xFF, 0xAA, 0xD5, 0xAA, 0xD5, 0xAA, 0xD5, 0xAA},
	
	-- Bricks
	bricks1 = {0x0, 0xDF, 0xDF, 0xDF, 0x0, 0xFD, 0xFD, 0xFD},
	bricks2 = {0xFF, 0x20, 0x20, 0x20, 0xFF, 0x2, 0x2, 0x2},
	bricks3 = {0x0, 0x0, 0xCF, 0xCF, 0x0, 0x0, 0xFC, 0xFC},
	bricks4 = {0x7E, 0xBD, 0xDB, 0xE7, 0xEF, 0xDF, 0xBF, 0x7F},
	bricks5 = {0x7E, 0xBD, 0xDB, 0xE7, 0xF7, 0xFB, 0xFD, 0xFE},
	
	-- Tins
	tins1 = {0x55, 0xAA, 0x65, 0xCA, 0x15, 0xAA, 0x55, 0xAA},
	tins2 = {0x55, 0xAA, 0x5D, 0xB6, 0x5D, 0x88, 0x41, 0xAA},
	tins3 = {0xAA, 0x7D, 0xBC, 0x7D, 0xBC, 0x7D, 0x80, 0x55},
	
	-- Decor
	decor1 = {0xB6, 0x6B, 0xBD, 0x6A, 0xB7, 0x55, 0xBE, 0x55},
	decor2 = {0x42, 0x9, 0x84, 0x22, 0x10, 0x88, 0x41, 0x24},
	decor3 = {0x92, 0x49, 0x94, 0x22, 0x55, 0x88, 0x4A, 0x25},
	decor4 = {0xAD, 0xD6, 0x6B, 0xB5, 0xDA, 0x56, 0xAD, 0xDA},
	decor5 = {0xE7, 0xDB, 0xBD, 0xA5, 0xBD, 0xDB, 0xB5, 0x6E},
	decor6 = {0xE3, 0xDD, 0xB6, 0xA5, 0xBD, 0xDB, 0x52, 0xBD},
	decor7 = {0xE7, 0xDB, 0xDB, 0xDB, 0xDB, 0xBD, 0x7E, 0xFF},
	decor8 = {0x66, 0xDB, 0xBD, 0x66, 0x66, 0xBD, 0xDB, 0x66},
	decor9 = {0x55, 0x55, 0x0, 0xDF, 0x10, 0xD7, 0x14, 0xD5},
	decor10 = {0x0, 0x7E, 0x42, 0x5A, 0x5A, 0x42, 0x7E, 0x0},
	decor11 = {0xFF, 0x81, 0xBD, 0xBD, 0xBD, 0xBD, 0x81, 0xFF},
	decor12 = {0xFF, 0x20, 0xAF, 0xAF, 0xAF, 0xAF, 0x20, 0xFF},
	decor14 = {0x80, 0xBF, 0xA0, 0xAE, 0xAA, 0xA2, 0xBE, 0x80},
	decor15 = {0x99, 0x42, 0x3C, 0x81, 0x81, 0x3C, 0x42, 0x99},
	decor16 = {0xCF, 0x9F, 0x3F, 0x6E, 0xE7, 0xF1, 0xF8, 0xEE},
	decor17 = {0x30, 0x60, 0xC0, 0x91, 0x18, 0xE, 0x7, 0x11},
	decor18 = {0x1E, 0xEE, 0xC2, 0xD9, 0x9B, 0x43, 0x77, 0x78},
	decor19 = {0x9D, 0x66, 0xDA, 0xBD, 0xBD, 0x5B, 0x66, 0xB9},
	decor20 = {0xFF, 0x55, 0xFF, 0xDD, 0xFF, 0x57, 0xFF, 0xDD},
	decor21 = {0x99, 0x7E, 0x66, 0xDB, 0xDB, 0x66, 0x7E, 0x99},
	decor22 = {0x66, 0x81, 0x99, 0x24, 0x24, 0x99, 0x81, 0x66},
	
	-- Noise
	noise1 = {0xA3, 0xA3, 0x15, 0x15, 0xB8, 0xB8, 0x55, 0x55},
	noise2 = {0x4, 0x20, 0x82, 0x10, 0x0, 0x44, 0x10, 0x1},
	noise3 = {0x0, 0x8, 0x41, 0x0, 0x10, 0x0, 0x2, 0x20},
	noise4 = {0x4, 0x80, 0x22, 0x10, 0x81, 0x8, 0x41, 0x8},
	noise5 = {0x44, 0x82, 0x10, 0x41, 0x20, 0x8, 0x41, 0x24},
	noise6 = {0xEB, 0xBE, 0xF7, 0xBA, 0xDF, 0xB6, 0xFB, 0x6D},
	noise7 = {0x66, 0x99, 0xA5, 0x5A, 0x5A, 0xA5, 0x99, 0x66},
	
	-- Emoji
	emojiSmile = {0xFF, 0x99, 0x99, 0xFF, 0xFF, 0xBD, 0xC3, 0xFF},
	emojiSad = {0xFF, 0xDB, 0x99, 0xFF, 0xFF, 0xC3, 0xBD, 0xFF},
	emojiFun = {0xFF, 0x99, 0x99, 0xFF, 0xBD, 0x81, 0xC3, 0xFF},
	
	-- Trees
	trees1 = {0xFF, 0xF7, 0xEB, 0xF7, 0xC9, 0xF7, 0x88, 0xF7},
	
	-- Misc
	usd = {0xDB, 0x81, 0x5B, 0x81, 0xDA, 0x5A, 0x81, 0xDB},

	-- -- Return patterns

	getPatterns = function (justnames)
		
		local patterns = {}

		for key, val in pairs(GFXP) do
			if type(GFXP[key]) == 'table' and #GFXP[key] ~= 0 then 
				if justnames then 
					table.insert(patterns, key)
				else
					patterns[key] = val
				end
			end
		end

		if justnames then
			table.sort(patterns, function (a,b) return a<b end)
		end
		
		return patterns
	end,

	-- Set selected pattern 

	set = function (val)
		if val then
			if type(val) == 'string' and GFXP[val] then
				return playdate.graphics.setPattern(GFXP[val])
			elseif  type(val) == 'table' and #val == 8 then
				return playdate.graphics.setPattern(val)
			else
				error('GFXP: Unknown type of pattern. Value is ' .. type(val))
			end
		
		else
			error('GFXP: Pattern not specified')
		end
	end,
}


--[[
	
	GFXP animation - creating animation from patterns.
	
	How to use

	-- step 1: import lib
		
		import 'helpers/gfxp'
		
		local gfxp = GFXP


	-- step 2: create animation instance
	-- there are two possible uses: animate a single pattern or animate multiple patterns
		
		-- multiple patterns
			-- options: 
			
				patterns = table with patterns, required
				patterns = {{0x7F, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF},
							{0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA},
							{0x0, 0x22, 0x0, 0x88, 0x0, 0x22, 0x0, 0x88}}
				
				-- or
				
				patterns = {gfxp.dots4, gfxp.gray, gfxp.darkgray}
				
				ticks = the rate of change, int, optional
				ticks = 1 -- changes will occur every frame, default option
				ticks = 2 -- changes will occur every second frame
				ticks = 10 -- changes will occur every 10 frame
				etc

			-- usage:
			
				local a = gfxp.animate:new(patterns)
				-- or
				local a = gfxp.animate:new(patterns, ticks)
			
			-- example:
				
				local a = gfxp.animate:new(gfxp.getPatterns(true))
				-- or
				local a = gfxp.animate:new({gfxp.dots4, gfxp.gray, gfxp.darkgray}, 10)


		-- single pattern
			-- options: 
				
				pattern = table with one pattern, required
				pattern = {0x0, 0xDF, 0xDF, 0xDF, 0x0, 0xFD, 0xFD, 0xFD}
				-- or
				pattern = gfxp.bricks1

				direction = direction of movement of the pattern, string, required
				direction = 'up'
				direction = 'right'
				direction = 'down'
				direction = 'left'
				
				ticks = the rate of change, int, optional
			
			-- usage:
				
				local a = gfxp.animate:new(pattern, direction, ticks)
			
			-- example:
			
				local a = gfxp.animate:new(gfxp.bricks1, 'right', 2)
				-- or
				local a = gfxp.animate:new({0x0, 0xDF, 0xDF, 0xDF, 0x0, 0xFD, 0xFD, 0xFD}, 'down')


	-- step 3: call when you update and draw some graphics
		
		-- usage:
		
			a:draw()
		
		-- example:
		
			function playdate.update()
				a:draw()
				playdate.graphics.fillRect(0, 0, 200, 120) -- for example
			end
		
		
]]--

GFXP.animate = {}
GFXP.animate.__index = GFXP.animate

function GFXP.animate:new(patterns, ...)
	
	if type(patterns) ~= 'table' or #patterns == 0 then
		error('GFXP.animate: Patterns not specified')
	end
	
	local self = {}
	setmetatable(self, metatable)

	local arg = {...}
	local mode = 1
	local ticks = 1
	local directions = {
		up = 1,
		right = 2,
		down = 3,
		left = 4
	}

	local currentDirection = 0
	local currentTicks = 0
	local currentPattern = nil
	local singleUpdateHandler = function () end

	if arg then

		if type(patterns[1]) == 'table' then

			ticks = arg[1] and arg[1] or ticks 

		elseif type(patterns[1]) == 'number' and #patterns == 8 then

			mode = 2
			currentDirection = directions[arg[1]] and directions[arg[1]] or 0
			ticks = arg[2] and arg[2] or ticks
			currentPattern = patterns

			if currentDirection == 1 then

				singleUpdateHandler = function ()
					table.insert(patterns, 8, table.remove(patterns, 1))
				end

			elseif currentDirection == 2 then
	
				singleUpdateHandler = function ()
					for i=1,8 do
						patterns[i] = (128 * (patterns[i] & 1)) + (patterns[i] >> 1)
					end
				end

			elseif currentDirection == 3 then

				singleUpdateHandler = function ()
					table.insert(patterns, 1, table.remove(patterns))
				end

			elseif currentDirection == 4 then

				singleUpdateHandler = function ()
					for i=1,8 do
						local val = patterns[i]
						patterns[i] = (val << 1) > 255 and (val << 1) - (255 * (val >> 7)) or (val << 1) + (255 * (val >> 7))
					end
				end
			else
				error('GFXP.animate: Single pattern direction not specified')
			end
		end
	end


	function self:update()
		
		currentTicks += 1
		
		if currentTicks % ticks == 0 then

			if mode == 1 then
				self:updateMultiple()
			else
				singleUpdateHandler()
			end
		end

		if currentTicks == 1000 then
			currentTicks = 0
		end
	end


	function self:updateMultiple()
		table.insert(patterns, 1, table.remove(patterns))
		local key, _ = next(patterns)
		currentPattern = patterns[key]
	end


	function self:draw()
		
		if not self then
			error('GFXP.animate: Call the instance')
		end

		self:update()

		if currentPattern then
			GFXP.set(currentPattern)
		end
	end

	return self
end







